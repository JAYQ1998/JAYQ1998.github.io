# Redis：为什么要用分布式缓存？

相关面试题 ：

- 为什么要用缓存？
- 本地缓存应该怎么做？
- 为什么要有分布式缓存?/为什么不直接用本地缓存?
- 多级缓存了解么？

发现很多小伙伴虽然项目中用了缓存，但是根本就没搞清楚为啥要用缓存，并且大部分小伙伴连最基本的缓存读写策略都没搞懂。

好好阅读这一节你不光可以在面试中用到，更可以在实际项目开发中用到！

## 缓存的基本思想 

很多朋友，只知道缓存可以提高系统性能以及减少请求相应时间，但是，不太清楚缓存的本质思想是什么。

缓存的基本思想其实很简单，就是我们非常熟悉的**空间换时间**。

其实，缓存的思想实际在**操作系统**或者其他地方都被大量用到。 

- CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。 
- 操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache）。

回归到业务系统来说：我们为了避免用户在请求数据的时候获取速度过于缓慢，所以我们在数据库之上增加了缓存这一层来弥补。

## 缓存使用带来的问题 

软件系统设计中没有银弹，往往任何技术的引入都像是把双刃剑。 你使用的方式得当，就能为系统带来很大的收益。否则，只是费了精力不讨好。

简单来说，为系统引入缓存之后往往会带来下面这些问题：

ps:其实我觉得引入本地缓存来做一些简单业务场景的话，实际带来的代价几乎可以忽略，下面 👇 主要是针对分布式缓存来说的。

1. 系统复杂性增加 ：引入缓存之后，你要维护缓存和数据库的数据一致性、维护热点缓存等等。

2. 系统开发成本往往会增加 ：引入缓存意味着系统需要一个单独的缓存服务，这是需要花费相应的成本的，并且这个成本还是很贵的，毕竟耗费的是宝贵的内存。但是，如果你只是简单的使用一下本地缓存存储一下简单的数据，并且数据量不大的话，那么就不需要单独去弄一个缓存服务。

## 本地缓存 

先来聊聊本地缓存，这个实际在很多项目中用的蛮多，特别是单体架构的时候。数据量不大，并且没有分布式要求的话，使用本地缓存还是可以的。

常见的单体架构图如下，我们使用 Nginx 来做负载均衡，部署两个相同的应用到服务器，两个服务使用同一个数据库，并且使用的是本地缓存。

![ 本地缓存.png](E:\JAYQ1998.github.io\docs\数据库\Redis\Redis：为什么要用分布式缓存？.assets\1659108036583-9b6db40d-75c9-4c6a-9581-30d0c5628f88.png)





#### 本地缓存的方案有哪些呢？

1. JDK 自带的 HashMap 和 ConcurrentHashMap 了。

   ConcurrentHashMap 可以看作是线程安全版本的 HashMap ，两者都是存放 key/value 形式的键值对。但是，大部分场景来说不会使用这两者当做缓存，因为只提供了缓存的功能，并没有提供其他诸如过期时间之类的功能。一个稍微完善一点的缓存框架至少要提供：**过期时间**、**淘汰机制**、**命中率统计**这三点。

2. Ehcache 、 Guava Cache 、 Spring Cache 这三者是使用的比较多的本地缓存框架。

   - Ehcache 的话相比于其他两者更加重量。

     不过，相比于 Guava Cache 、 Spring Cache 来说， Ehcache 支持可以嵌入到 hibernate 和 mybatis 作为多级缓存，并且可以将缓存的数据持久化到本地磁盘中、同时也提供了集群方案（比较鸡肋，可忽略）。

   - Guava Cache 和 Spring Cache 两者的话比较像。Guava 相比于 Spring Cache 的话使用的更多一点，它提供了 API 非常方便我们使用，同时也提供了设置缓存有效时间等功能。它的内部实现也比较干净，很多地方都和 ConcurrentHashMap 的思想有异曲同工之妙。
   - 使用 Spring Cache 的注解实现缓存的话，代码会看着很干净和优雅，但是很容易出现问题比如**缓存穿透、内存溢出**。



3. 后起之秀 Caffeine。

   相比于 Guava 来说 Caffeine 在各个方面比如性能要更加优秀，一般建议使用其来替代 Guava 。并且， Guava 和 Caffeine 的使用方式很像！

本地缓存固然好，但是缺陷也很明显，比如**多个相同服务之间的本地缓存的数据无法共享**。

## 分布式缓存 

本地的缓存的优势非常明显：低依赖、轻量、简单、成本低。

但是，本地缓存存在下面这些缺陷：

1. 本地缓存对分布式架构支持不友好，比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是**无法共享**的，因为本地缓存只在当前机器上有。

2. 本地缓存容量受服务部署所在的机器限制明显。 如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。

我们可以把分布式缓存（Distributed Cache） 看作是一种**内存数据库的服务**，它的最终作用就是提供**缓存数据**的服务。

如下图所示，就是一个简单的使用分布式缓存的架构图。我们使用 Nginx 来做负载均衡，部署两个相同的应用到服务器，两个服务使用同一个数据库和缓存。

![分布式缓存.png](E:\JAYQ1998.github.io\docs\数据库\Redis\Redis：为什么要用分布式缓存？.assets\1659108045621-7ea6934e-9d5d-4aa7-8c9b-4c34224d0062.png)





使用分布式缓存之后，缓存服务可以部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。 并且，单独的分布式缓存服务的性能、容量和提供的功能都要更加强大。



使用分布式缓存的缺点也很显而易见:

- 分布式缓存引入额外的服务比如 Redis 或 Memcached
- 需要单独保证 Redis 或 Memcached 服务的高可用。

## 多级缓存 

我们这里只来简单聊聊 本地缓存 + 分布式缓存 的多级缓存方案。

这个时候估计有很多小伙伴就会问了：既然用了分布式缓存，为什么还要用本地缓存呢？ 。

的确，一般情况下，我们也是不建议使用多级缓存的，这会增加维护负担（比如你需要保证一级缓存和二级缓存的数据一致性），并且，实际带来的提升效果对于绝大部分项目来说其实并不是很大。



多级缓存方案中，第一级缓存（L1）使用本地内存（比如 Caffeine)），第二级缓存（L2）使用分布式缓存（比如 Redis）。读取缓存数据的时候，我们先从 L1 中读取，读取不到的时候再去 L2 读取。这样可以降低 L2 的压力，减少 L2 的读次数。并且，本地内存的访问速度是最快的，不存在什么网络开销。

[J2Cache](https://gitee.com/ld/J2Cache) 就是一个基于本地内存和分布式缓存的两级 Java 缓存框架。